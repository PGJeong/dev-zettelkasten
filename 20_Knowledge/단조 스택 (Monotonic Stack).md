## 1. 정의

단조 스택은 스택 내부의 원소들을 **일정한 순서**(오름차순 또는 내림차순)로 유지하는 자료구조 기법이다. 새로운 원소를 삽입할 때 이 규칙을 깨뜨리는 기존 원소들을 제거(`pop`)함으로써 단조성을 유지한다.

---
## 2. 유형 및 특징

- **단조 증가 스택 (Monotonic Increasing Stack):** 하단에서 상단으로 갈수록 값이 커지는 상태 ($1 < 3 < 5$)
	- 새 값이 기존 `top`보다 **작으면** `pop`.
	- **용도:** 나보다 작은 가장 가까운 왼쪽/오른쪽 원소 찾기.
  
- **단조 감소 스택 (Monotonic Decreasing Stack):** 하단에서 상단으로 갈수록 값이 작아지는 상태 ($8 > 5 > 2$)
    - 새 값이 기존 `top`보다 **크면** `pop`.
    - **용도:** 나보다 큰 가장 가까운 왼쪽/오른쪽 원소 찾기.

---
## 3. 핵심 작동 원리

1. **관찰:** 데이터를 순차적으로 탐색하며 스택에 넣는다.
    
2. **비교:** 현재 데이터가 스택의 `top`과 비교하여 단조성을 해친다면, 조건이 만족될 때까지 스택을 `pop`한다.
    
3. **처리:** `pop`되는 원소들은 현재 데이터에 의해 **'특정 조건(나보다 큰/작은 놈 등장)'** 이 달성된 놈들이다.
    
4. **삽입:** 현재 데이터를 스택에 넣는다.

---
## 4. 왜 사용하는가? (Efficiency)

- **시간 복잡도:** 각 원소는 스택에 정확히 **한 번 push**되고 **한 번 pop**된다. 따라서 전체 시간 복잡도는 **$O(N)$이다.
    
- **중첩 루프 최적화:** 보통 "나보다 큰/작은 다음 원소를 찾아라"는 문제는 단순 구현 시 $O(N^2)$이 걸리지만, 단조 스택을 쓰면 선형 시간에 해결 가능하다.

---
## 5. Java 구현 꿀팁 (Implementation)

- **인덱스 저장:** 스택에 값(`value`)을 직접 넣기보다 **인덱스(`index`)** 를 넣는 것이 훨씬 유용하다. 인덱스만 알면 배열에서 값(`A[index]`)을 언제든 찾을 수 있고, 위치 관계도 계산할 수 있기 때문이다.
    
- **[[../20_Knowledge/ArrayDeque]] 활용:** `Stack` 클래스보다 `ArrayDeque`를 사용하여 성능을 극대화한다.

```
// 단조 감소 스택 예시 (오큰수 찾기)
Deque<Integer> stack = new ArrayDeque<>();
for (int i = 0; i < N; i++) {
    // 현재 값 A[i]가 스택 top보다 크면, top의 오큰수는 A[i]이다.
    while (!stack.isEmpty() && A[stack.peekLast()] < A[i]) {
        int index = stack.removeLast();
        NGE[index] = A[i];
    }
    stack.addLast(i); // 현재 인덱스 삽입
}
```
